# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14m0Q03c1p7VEkNTxF8QalZ4uu1-YREkP
"""

import json
import re
from typing import Tuple, List, Dict, Set
from statistics import mean
from datetime import datetime
from collections import defaultdict

### 1. Charger les produits depuis un fichier JSONL ###
def parse_url(url: str) -> Tuple[str, str]:
    """ Extrait l'ID et la variante depuis une URL de produit. """
    id_pattern = r'/product/(\d+)'
    variant_pattern = r'variant=([^&]+)'

    id_match = re.search(id_pattern, url)
    if not id_match:
        raise ValueError(f"ID produit non trouvé dans l'URL: {url}")
    product_id = id_match.group(1)

    variant_match = re.search(variant_pattern, url)
    variant = variant_match.group(1) if variant_match else ''

    return product_id, variant

def load_jsonl(file_path: str) -> List[Dict]:
    """ Charge un fichier JSONL et extrait les IDs et variantes. """
    products = []

    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            try:
                if line.strip():
                    product = json.loads(line.strip())
                    product_id, variant = parse_url(product['url'])
                    product['product_id'] = product_id
                    product['variant'] = variant
                    products.append(product)
            except Exception as e:
                print(f"Erreur lors du chargement d'un produit: {e}")

    return products

### 2. Création d'un index inversé pour titres et descriptions ###

class InvertedIndex:
    def __init__(self):
        self.stopwords = {"i", "me", "my", "myself", "we", "our", "ours", "ourselves", "you", "your", "yours", "yourself", "yourselves",
                          "he", "him", "his", "himself", "she", "her", "hers", "herself", "it", "its", "itself", "they", "them", "their",
                          "theirs", "themselves", "what", "which", "who", "whom", "this", "that", "these", "those", "am", "is", "are",
                          "was", "were", "be", "been", "being", "have", "has", "had", "having", "do", "does", "did", "doing", "a", "an",
                          "the", "and", "but", "if", "or", "because", "as", "until", "while", "of", "at", "by", "for", "with", "about",
                          "against", "between", "into", "through", "during", "before", "after", "above", "below", "to", "from", "up",
                          "down", "in", "out", "on", "off", "over", "under", "again", "further", "then", "once", "here", "there", "when",
                          "where", "why", "how", "all", "any", "both", "each", "few", "more", "most", "other", "some", "such", "no", "nor",
                          "not", "only", "own", "same", "so", "than", "too", "very", "s", "t", "can", "will", "just", "don", "should", "now"}

    def tokenize(self, text: str) -> List[str]:
        """ Tokenize et nettoie le texte en enlevant la ponctuation et les stopwords. """
        text = text.lower()
        text = re.sub(r'[^\w\s]', '', text)  # Enlever la ponctuation
        tokens = text.split()
        # Filtrer les stopwords
        return [token for token in tokens if token not in self.stopwords]

    def create_index(self, products: List[Dict], field: str) -> Dict[str, Dict[str, Set[int]]]:
        """ Crée un index inversé pour un champ donné (titre ou description) en enregistrant les URL et positions. """
        index = defaultdict(lambda: defaultdict(set))

        for product in products:
            product_url = product['url']
            tokens = self.tokenize(product.get(field, ""))
            for position, token in enumerate(tokens):
                index[token][product_url].add(position)

        return index

def create_title_and_description_indexes(products: List[Dict]) -> Tuple[Dict[str, Dict[str, Set[int]]], Dict[str, Dict[str, Set[int]]]]:
    """ Crée les index pour les titres et descriptions avec URL et position. """
    indexer = InvertedIndex()
    title_index = indexer.create_index(products, 'title')
    description_index = indexer.create_index(products, 'description')
    return title_index, description_index


### 3. Index des reviews (nombre total, moyenne, dernière note) ###
def create_reviews_index(products: List[Dict]) -> Dict[str, Dict]:
    """ Crée un index des reviews avec des statistiques. """
    reviews_index = {}

    for product in products:
        product_id = product['product_id']
        reviews = product.get('product_reviews', [])

        if not reviews:
            continue

        total_reviews = len(reviews)
        ratings = [review['rating'] for review in reviews]
        average_rating = mean(ratings)

        dated_reviews = [(datetime.fromisoformat(review['date']), review['rating']) for review in reviews]
        last_review_date, last_rating = max(dated_reviews, key=lambda x: x[0])

        reviews_index[product_id] = {
            'total_reviews': total_reviews,
            'average_rating': round(average_rating, 2),
            'last_rating': last_rating
        }

    return reviews_index

### 4. Index des features (marque, origine, etc.) ###
def create_features_indexes(products: List[Dict]) -> Dict[str, Dict[str, Set[str]]]:
    """
    Crée un index inversé pour toutes les features trouvées dans product_features.

    """
    features_indexes = {}

    for product in products:
        product_url = product['url']  # Utilisation de l'URL du produit
        features = product.get('product_features', {})

        for feature, value in features.items():
            if isinstance(value, str):  # On s'assure que c'est une valeur texte
                value = value.lower()  # Normalisation en minuscules

                # Initialisation du dictionnaire si la feature n'est pas encore indexée
                if feature not in features_indexes:
                    features_indexes[feature] = {}

                # Ajout de l'URL du produit à la valeur correspondante
                if value not in features_indexes[feature]:
                    features_indexes[feature][value] = set()
                features_indexes[feature][value].add(product_url)

    return features_indexes


### 5. Sauvegarde des index ###
def save_index_to_json(index: Dict, filename: str):
    """ Sauvegarde un index en JSON en convertissant les ensembles en listes. """
    def convert(obj):
        if isinstance(obj, set):
            return list(obj)  # Convertir les ensembles en listes
        if isinstance(obj, dict):
            return {k: convert(v) for k, v in obj.items()}
        return obj

    with open(filename, 'w', encoding='utf-8') as f:
        json.dump(convert(index), f, indent=4, ensure_ascii=False)


### 6. Main ###
if __name__ == "__main__":
    # Charger les produits
    products = load_jsonl("products.jsonl")

    # Créer les index
    title_index, description_index = create_title_and_description_indexes(products)
    reviews_index = create_reviews_index(products)
    features_indexes = create_features_indexes(products)
    positional_index = create_positional_index(products)

    # Sauvegarder les index
    save_index_to_json(title_index, "title_index.json")
    save_index_to_json(description_index, "description_index.json")
    save_index_to_json(reviews_index, "reviews_index.json")
    save_index_to_json(features_indexes, "features_indexes.json")

    # Afficher un résumé
    print(f"Indexation terminée ✅")
    print(f"Nombre de tokens dans l'index des titres : {len(title_index)}")
    print(f"Nombre de tokens dans l'index des descriptions : {len(description_index)}")
    print(f"Nombre de produits indexés pour les reviews : {len(reviews_index)}")
    print(f"Nombre de types de features indexées : {len(features_indexes)}")
    print(f"Nombre de mots indexés pour l'index de positions : {len(positional_index)}")